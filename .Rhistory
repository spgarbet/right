check <- qaly.unadj %>% filter(name %in% c("patient10574_1","patient54211_1")) %>% arrange(name,value)
check <- qaly.unadj %>% filter(name %in% c("patient10574_1","patient54211_1")) %>% arrange(name)
View(check)
View(check2)
View(check3)
qaly.i <- qaly2 %>% select(name, value, time, utility) %>%
mutate(qaly.d = discount_value(utility,A=value,B=time)) #discounted QALY for each period of time
QALY = qaly.i %>% group_by(name) %>% summarise(dQALY = sum(qaly.i)/365.25)
COST = arrivals %>% group_by(name) %>% summarise(dCOST = sum(discounted_cost))
percap <- merge(QALY,COST,by="name")
qaly1
QALY = qaly.i %>% group_by(name) %>% summarise(dQALY = sum(qaly.i)/365.25)
View(qaly.i)
QALY = qaly.i %>% group_by(name) %>% summarise(dQALY = sum(qaly.d)/365.25)
COST = arrivals %>% group_by(name) %>% summarise(dCOST = sum(discounted_cost))
percap <- merge(QALY,COST,by="name")
percap
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN )
View(avgsum)
View(avgsum)
arrivals <- results %>%  mutate(name = paste0(name,"_",replication))
# Make all resources a factor (this allows for null events to still get summaries)
arrivals$resource <- factor(arrivals$resource, counters)
# Adjust all event end times from the inputs$durations
mapply(function(value, name){
arrivals[arrivals$resource == name,]$end_time <<-arrivals[arrivals$resource == name,]$start_time + value
}, value=inputs$durations, name=names(inputs$durations) )
# Truncate to end of study or life
end_times <- arrivals[arrivals$resource == 'time_in_model',]
arrivals$end_time <- pmin(arrivals$end_time,
plyr::join(arrivals[,c("name","end_time")], end_times[,c("name","end_time")], by="name", match="first")[,3])
# Compute total activity times
arrivals$activity_time <- arrivals$end_time - arrivals$start_time
# Computes discounted rate of time
arrivals$discounted_time <- discount_value(value=1,A=arrivals$start_time,B=arrivals$end_time)
# Compute Event base cost map
idx <- function(str) {as.numeric(factor(str, levels=levels(arrivals$resource)))}
base_cost_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$costs), FUN=function(name){
base_cost_map[idx(name)] <<- inputs$costs[[name]]
})
# Compute Disutility cost map
base_disutility_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$disutilities), FUN=function(name){
base_disutility_map[idx(name)] <<- inputs$disutilities[[name]]
})
names(base_disutility_map) = levels(arrivals$resource)
arrivals$cost <- base_cost_map[as.numeric(arrivals$resource)]
arrivals$discounted_cost <- ifelse(arrivals$activity_time>0,
discount_value(value=arrivals$cost,A=arrivals$start_time,B=arrivals$end_time),
discount(value = arrivals$cost,A=arrivals$start_time))
arrivals$disutility = base_disutility_map[arrivals$resource]
qaly1 <- arrivals %>% group_by(name) %>%
arrange(start_time) %>% mutate(utility = ifelse(row_number()==1,1,NA)) %>% filter(disutility>0 | utility>0) %>% #cross out events that have no impact on utility
select(name,resource,start_time,end_time,activity_time,disutility) %>%
merge(type,by="resource",all.x=TRUE) %>% #attach type of events: temp vs. permanent disutility
mutate(us=disutility,ue=disutility*(-type)) %>%  #us/ue stand for disutility at start/end time: temp event will add back disutility at end time
select(name,start_time,end_time,us,ue,resource,type) %>% melt(id.vars=c("name","resource","us","ue","type")) %>% arrange(value) %>% #separate and spread start/end time
mutate(disutility=ifelse(variable=="start_time",us,ue)) %>% arrange(name,value,desc(variable)) %>% #match disutility with start/end time
group_by(name) %>% mutate(time=lead(value)) %>% mutate(dtime=ifelse(row_number()>1,time-lag(time),time)) %>% filter(!is.na(dtime)) %>%
filter(!(type==0 & dtime==0)) #For events that permanently reduce utility, this deletes double counts of the event and prevent double counting of disutility
#For temp event, we need to keep two records (start & end) in the datasets in order to adding back disutility at end time
qaly2 <- qaly1 %>% mutate(cum1=ifelse(type==1 | is.na(type),0,disutility)) %>% #For permanent events (type=0), pass disutility to accumulate
group_by(name) %>% mutate(temp_u=1-cumsum(cum1)) %>%
mutate(cum2=ifelse(type==0 | is.na(type),0,disutility)) %>% mutate(utility=temp_u-cumsum(cum2)) %>% #For temp events, deduct accumulative disutility from temp_u
filter(utility>0) #do not count negative/zero utility in qaly computation
qaly.i <- qaly2 %>% select(name, value, time, utility) %>%
mutate(qaly.d = discount_value(utility,A=value,B=time)) #discounted QALY for each period of time
QALY = qaly.i %>% group_by(name) %>% summarise(dQALY = sum(qaly.d)/365.25)
COST = arrivals %>% group_by(name) %>% summarise(dCOST = sum(discounted_cost))
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN )
#  qaly.cost = QALY %>% merge(COST,by="name",all.x=TRUE)
View(avgsum)
View(QALY)
View(COST)
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN )
View(avgsum)
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN, digits=4 )
View(avgsum)
View(QALY)
options("scipen"=100, "digits"=5)
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN )
View(avgsum)
View(avgsum)
View(avgsum)
cost.qaly <- function(raw,inputs)
{
arrivals <- raw %>%  mutate(name = paste0(name,"_",replication))
#arrivals <- results %>%  mutate(name = paste0(name,"_",replication))
# Make all resources a factor (this allows for null events to still get summaries)
arrivals$resource <- factor(arrivals$resource, counters)
# Adjust all event end times from the inputs$durations
mapply(function(value, name){
arrivals[arrivals$resource == name,]$end_time <<-arrivals[arrivals$resource == name,]$start_time + value
}, value=inputs$durations, name=names(inputs$durations) )
# Truncate to end of study or life
end_times <- arrivals[arrivals$resource == 'time_in_model',]
arrivals$end_time <- pmin(arrivals$end_time,
plyr::join(arrivals[,c("name","end_time")], end_times[,c("name","end_time")], by="name", match="first")[,3])
# Compute total activity times
arrivals$activity_time <- arrivals$end_time - arrivals$start_time
# Computes discounted rate of time
arrivals$discounted_time <- discount_value(value=1,A=arrivals$start_time,B=arrivals$end_time)
# Compute Event base cost map
idx <- function(str) {as.numeric(factor(str, levels=levels(arrivals$resource)))}
base_cost_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$costs), FUN=function(name){
base_cost_map[idx(name)] <<- inputs$costs[[name]]
})
# Compute Disutility cost map
base_disutility_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$disutilities), FUN=function(name){
base_disutility_map[idx(name)] <<- inputs$disutilities[[name]]
})
names(base_disutility_map) = levels(arrivals$resource)
arrivals$cost <- base_cost_map[as.numeric(arrivals$resource)]
arrivals$discounted_cost <- ifelse(arrivals$activity_time>0,
discount_value(value=arrivals$cost,A=arrivals$start_time,B=arrivals$end_time),
discount(value = arrivals$cost,A=arrivals$start_time))
arrivals$disutility = base_disutility_map[arrivals$resource]
qaly1 <- arrivals %>% group_by(name) %>%
arrange(start_time) %>% mutate(utility = ifelse(row_number()==1,1,NA)) %>% filter(disutility>0 | utility>0) %>% #cross out events that have no impact on utility
select(name,resource,start_time,end_time,activity_time,disutility) %>%
merge(type,by="resource",all.x=TRUE) %>% #attach type of events: temp vs. permanent disutility
mutate(us=disutility,ue=disutility*(-type)) %>%  #us/ue stand for disutility at start/end time: temp event will add back disutility at end time
select(name,start_time,end_time,us,ue,resource,type) %>% melt(id.vars=c("name","resource","us","ue","type")) %>% arrange(value) %>% #separate and spread start/end time
mutate(disutility=ifelse(variable=="start_time",us,ue)) %>% arrange(name,value,desc(variable)) %>% #match disutility with start/end time
group_by(name) %>% mutate(time=lead(value)) %>% mutate(dtime=ifelse(row_number()>1,time-lag(time),time)) %>% filter(!is.na(dtime)) %>%
filter(!(type==0 & dtime==0)) #For events that permanently reduce utility, this deletes double counts of the event and prevent double counting of disutility
#For temp event, we need to keep two records (start & end) in the datasets in order to adding back disutility at end time
qaly2 <- qaly1 %>% mutate(cum1=ifelse(type==1 | is.na(type),0,disutility)) %>% #For permanent events (type=0), pass disutility to accumulate
group_by(name) %>% mutate(temp_u=1-cumsum(cum1)) %>%
mutate(cum2=ifelse(type==0 | is.na(type),0,disutility)) %>% mutate(utility=temp_u-cumsum(cum2)) %>% #For temp events, deduct accumulative disutility from temp_u
filter(utility>0) #do not count negative/zero utility in qaly computation
qaly.i <- qaly2 %>% select(name, value, time, utility) %>%
mutate(qaly.d = discount_value(utility,A=value,B=time)) #discounted QALY for each period of time
QALY = qaly.i %>% group_by(name) %>% summarise(dQALY = sum(qaly.d)/365.25)
COST = arrivals %>% group_by(name) %>% summarise(dCOST = sum(discounted_cost))
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN )
#  qaly.cost = QALY %>% merge(COST,by="name",all.x=TRUE)
#  out = list(arrivals=arrivals,qaly= qaly.i,cost = cost.i,summary = qaly.cost)
#  return(out)
return(avgsum)
}
cost.qaly(results,inputs)
View(qaly1)
source('inputs.R')
source('inputs.R')
inputs$type
inputs$type %>% data.frame()
inputs$type %>% unlist() %>% data.frame()
results <- read.csv("/Users/zilu/Desktop/myresult/combine2/3-drug-raw.csv")
View(results)
###########
library(plyr)
library(dplyr)
library(tidyr)
library(reshape2)
options("scipen"=100, "digits"=6)
annual_discount_rate <- 0.03
cont_discount_rate   <- -log(1-annual_discount_rate) # Yearly Time Scale
discounted_cost <- function(start_day, end_day, base_yearly_cost, rate = cont_discount_rate)
{
#base_yearly_cost*(exp(-rate*start_day/365) - exp(-rate*end_day/365))/rate
base_yearly_cost / (exp(-rate*((end_day-start_day)/365)))
}
discount_value = function(value,ar=annual_discount_rate,A,B)
{
r <- (1 + ar)^(1/365)-1
(value/r)*(exp(-r*A)-exp(-r*B))
}
discount = function(value,ar=annual_discount_rate,A) value / (1+ar)^(A/365.25)
cost.qaly <- function(raw,inputs)
{
arrivals <- raw %>%  mutate(name = paste0(name,"_",replication))
#arrivals <- results %>%  mutate(name = paste0(name,"_",replication))
# Make all resources a factor (this allows for null events to still get summaries)
arrivals$resource <- factor(arrivals$resource, counters)
# Adjust all event end times from the inputs$durations
mapply(function(value, name){
arrivals[arrivals$resource == name,]$end_time <<-arrivals[arrivals$resource == name,]$start_time + value
}, value=inputs$durations, name=names(inputs$durations) )
# Truncate to end of study or life
end_times <- arrivals[arrivals$resource == 'time_in_model',]
arrivals$end_time <- pmin(arrivals$end_time,
plyr::join(arrivals[,c("name","end_time")], end_times[,c("name","end_time")], by="name", match="first")[,3])
# Compute total activity times
arrivals$activity_time <- arrivals$end_time - arrivals$start_time
# Computes discounted rate of time
arrivals$discounted_time <- discount_value(value=1,A=arrivals$start_time,B=arrivals$end_time)
# Compute Event base cost map
idx <- function(str) {as.numeric(factor(str, levels=levels(arrivals$resource)))}
base_cost_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$costs), FUN=function(name){
base_cost_map[idx(name)] <<- inputs$costs[[name]]
})
# Compute Disutility cost map
base_disutility_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$disutilities), FUN=function(name){
base_disutility_map[idx(name)] <<- inputs$disutilities[[name]]
})
names(base_disutility_map) = levels(arrivals$resource)
arrivals$cost <- base_cost_map[as.numeric(arrivals$resource)]
arrivals$discounted_cost <- ifelse(arrivals$activity_time>0,
discount_value(value=arrivals$cost,A=arrivals$start_time,B=arrivals$end_time),
discount(value = arrivals$cost,A=arrivals$start_time))
arrivals$disutility = base_disutility_map[arrivals$resource]
qaly1 <- arrivals %>% group_by(name) %>%
arrange(start_time) %>% mutate(utility = ifelse(row_number()==1,1,NA)) %>% filter(disutility>0 | utility>0) %>% #cross out events that have no impact on utility
select(name,resource,start_time,end_time,activity_time,disutility) %>%
merge(inputs$type %>% unlist() %>% data.frame(),by="resource",all.x=TRUE) %>% #attach type of events: temp vs. permanent disutility
mutate(us=disutility,ue=disutility*(-type)) %>%  #us/ue stand for disutility at start/end time: temp event will add back disutility at end time
select(name,start_time,end_time,us,ue,resource,type) %>% melt(id.vars=c("name","resource","us","ue","type")) %>% arrange(value) %>% #separate and spread start/end time
mutate(disutility=ifelse(variable=="start_time",us,ue)) %>% arrange(name,value,desc(variable)) %>% #match disutility with start/end time
group_by(name) %>% mutate(time=lead(value)) %>% mutate(dtime=ifelse(row_number()>1,time-lag(time),time)) %>% filter(!is.na(dtime)) %>%
filter(!(type==0 & dtime==0)) #For events that permanently reduce utility, this deletes double counts of the event and prevent double counting of disutility
#For temp event, we need to keep two records (start & end) in the datasets in order to adding back disutility at end time
qaly2 <- qaly1 %>% mutate(cum1=ifelse(type==1 | is.na(type),0,disutility)) %>% #For permanent events (type==0), pass disutility to accumulate
group_by(name) %>% mutate(temp_u=1-cumsum(cum1)) %>%
mutate(cum2=ifelse(type==0 | is.na(type),0,disutility)) %>% mutate(utility=temp_u-cumsum(cum2)) %>% #For temp events, deduct accumulative disutility from temp_u
filter(utility>0) #do not count negative/zero utility in qaly computation
qaly.i <- qaly2 %>% select(name, value, time, utility) %>%
mutate(qaly.d = discount_value(utility,A=value,B=time)) #discounted QALY for each period of time
QALY = qaly.i %>% group_by(name) %>% summarise(dQALY = sum(qaly.d)/365.25)
COST = arrivals %>% group_by(name) %>% summarise(dCOST = sum(discounted_cost))
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN )
return(avgsum)
}
cost.qaly(results,inputs)
Q
cost.qaly <- function(raw,inputs)
{
arrivals <- raw %>%  mutate(name = paste0(name,"_",replication))
#arrivals <- results %>%  mutate(name = paste0(name,"_",replication))
# Make all resources a factor (this allows for null events to still get summaries)
arrivals$resource <- factor(arrivals$resource, counters)
# Adjust all event end times from the inputs$durations
mapply(function(value, name){
arrivals[arrivals$resource == name,]$end_time <<-arrivals[arrivals$resource == name,]$start_time + value
}, value=inputs$durations, name=names(inputs$durations) )
# Truncate to end of study or life
end_times <- arrivals[arrivals$resource == 'time_in_model',]
arrivals$end_time <- pmin(arrivals$end_time,
plyr::join(arrivals[,c("name","end_time")], end_times[,c("name","end_time")], by="name", match="first")[,3])
# Compute total activity times
arrivals$activity_time <- arrivals$end_time - arrivals$start_time
# Computes discounted rate of time
arrivals$discounted_time <- discount_value(value=1,A=arrivals$start_time,B=arrivals$end_time)
# Compute Event base cost map
idx <- function(str) {as.numeric(factor(str, levels=levels(arrivals$resource)))}
base_cost_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$costs), FUN=function(name){
base_cost_map[idx(name)] <<- inputs$costs[[name]]
})
# Compute Disutility cost map
base_disutility_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$disutilities), FUN=function(name){
base_disutility_map[idx(name)] <<- inputs$disutilities[[name]]
})
names(base_disutility_map) = levels(arrivals$resource)
arrivals$cost <- base_cost_map[as.numeric(arrivals$resource)]
arrivals$discounted_cost <- ifelse(arrivals$activity_time>0,
discount_value(value=arrivals$cost,A=arrivals$start_time,B=arrivals$end_time),
discount(value = arrivals$cost,A=arrivals$start_time))
arrivals$disutility = base_disutility_map[arrivals$resource]
type <- inputs$type %>% unlist() %>% data.frame()
qaly1 <- arrivals %>% group_by(name) %>%
arrange(start_time) %>% mutate(utility = ifelse(row_number()==1,1,NA)) %>% filter(disutility>0 | utility>0) %>% #cross out events that have no impact on utility
select(name,resource,start_time,end_time,activity_time,disutility) %>%
merge(type,by="resource",all.x=TRUE) %>% #attach type of events: temp vs. permanent disutility
mutate(us=disutility,ue=disutility*(-type)) %>%  #us/ue stand for disutility at start/end time: temp event will add back disutility at end time
select(name,start_time,end_time,us,ue,resource,type) %>% melt(id.vars=c("name","resource","us","ue","type")) %>% arrange(value) %>% #separate and spread start/end time
mutate(disutility=ifelse(variable=="start_time",us,ue)) %>% arrange(name,value,desc(variable)) %>% #match disutility with start/end time
group_by(name) %>% mutate(time=lead(value)) %>% mutate(dtime=ifelse(row_number()>1,time-lag(time),time)) %>% filter(!is.na(dtime)) %>%
filter(!(type==0 & dtime==0)) #For events that permanently reduce utility, this deletes double counts of the event and prevent double counting of disutility
#For temp event, we need to keep two records (start & end) in the datasets in order to adding back disutility at end time
qaly2 <- qaly1 %>% mutate(cum1=ifelse(type==1 | is.na(type),0,disutility)) %>% #For permanent events (type==0), pass disutility to accumulate
group_by(name) %>% mutate(temp_u=1-cumsum(cum1)) %>%
mutate(cum2=ifelse(type==0 | is.na(type),0,disutility)) %>% mutate(utility=temp_u-cumsum(cum2)) %>% #For temp events, deduct accumulative disutility from temp_u
filter(utility>0) #do not count negative/zero utility in qaly computation
qaly.i <- qaly2 %>% select(name, value, time, utility) %>%
mutate(qaly.d = discount_value(utility,A=value,B=time)) #discounted QALY for each period of time
QALY = qaly.i %>% group_by(name) %>% summarise(dQALY = sum(qaly.d)/365.25)
COST = arrivals %>% group_by(name) %>% summarise(dCOST = sum(discounted_cost))
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN )
return(avgsum)
}
cost.qaly(results,inputs)
Q
View(type)
type <- read.csv("/Users/zilu/Box Sync/today/disutility_type.csv")
cost.qaly <- function(raw,inputs)
{
arrivals <- raw %>%  mutate(name = paste0(name,"_",replication))
#arrivals <- results %>%  mutate(name = paste0(name,"_",replication))
# Make all resources a factor (this allows for null events to still get summaries)
arrivals$resource <- factor(arrivals$resource, counters)
# Adjust all event end times from the inputs$durations
mapply(function(value, name){
arrivals[arrivals$resource == name,]$end_time <<-arrivals[arrivals$resource == name,]$start_time + value
}, value=inputs$durations, name=names(inputs$durations) )
# Truncate to end of study or life
end_times <- arrivals[arrivals$resource == 'time_in_model',]
arrivals$end_time <- pmin(arrivals$end_time,
plyr::join(arrivals[,c("name","end_time")], end_times[,c("name","end_time")], by="name", match="first")[,3])
# Compute total activity times
arrivals$activity_time <- arrivals$end_time - arrivals$start_time
# Computes discounted rate of time
arrivals$discounted_time <- discount_value(value=1,A=arrivals$start_time,B=arrivals$end_time)
# Compute Event base cost map
idx <- function(str) {as.numeric(factor(str, levels=levels(arrivals$resource)))}
base_cost_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$costs), FUN=function(name){
base_cost_map[idx(name)] <<- inputs$costs[[name]]
})
# Compute Disutility cost map
base_disutility_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$disutilities), FUN=function(name){
base_disutility_map[idx(name)] <<- inputs$disutilities[[name]]
})
names(base_disutility_map) = levels(arrivals$resource)
arrivals$cost <- base_cost_map[as.numeric(arrivals$resource)]
arrivals$discounted_cost <- ifelse(arrivals$activity_time>0,
discount_value(value=arrivals$cost,A=arrivals$start_time,B=arrivals$end_time),
discount(value = arrivals$cost,A=arrivals$start_time))
arrivals$disutility = base_disutility_map[arrivals$resource]
#type <- inputs$type %>% unlist() %>% data.frame()
qaly1 <- arrivals %>% group_by(name) %>%
arrange(start_time) %>% mutate(utility = ifelse(row_number()==1,1,NA)) %>% filter(disutility>0 | utility>0) %>% #cross out events that have no impact on utility
select(name,resource,start_time,end_time,activity_time,disutility) %>%
merge(type,by="resource",all.x=TRUE) %>% #attach type of events: temp vs. permanent disutility
mutate(us=disutility,ue=disutility*(-type)) %>%  #us/ue stand for disutility at start/end time: temp event will add back disutility at end time
select(name,start_time,end_time,us,ue,resource,type) %>% melt(id.vars=c("name","resource","us","ue","type")) %>% arrange(value) %>% #separate and spread start/end time
mutate(disutility=ifelse(variable=="start_time",us,ue)) %>% arrange(name,value,desc(variable)) %>% #match disutility with start/end time
group_by(name) %>% mutate(time=lead(value)) %>% mutate(dtime=ifelse(row_number()>1,time-lag(time),time)) %>% filter(!is.na(dtime)) %>%
filter(!(type==0 & dtime==0)) #For events that permanently reduce utility, this deletes double counts of the event and prevent double counting of disutility
#For temp event, we need to keep two records (start & end) in the datasets in order to adding back disutility at end time
qaly2 <- qaly1 %>% mutate(cum1=ifelse(type==1 | is.na(type),0,disutility)) %>% #For permanent events (type==0), pass disutility to accumulate
group_by(name) %>% mutate(temp_u=1-cumsum(cum1)) %>%
mutate(cum2=ifelse(type==0 | is.na(type),0,disutility)) %>% mutate(utility=temp_u-cumsum(cum2)) %>% #For temp events, deduct accumulative disutility from temp_u
filter(utility>0) #do not count negative/zero utility in qaly computation
qaly.i <- qaly2 %>% select(name, value, time, utility) %>%
mutate(qaly.d = discount_value(utility,A=value,B=time)) #discounted QALY for each period of time
QALY = qaly.i %>% group_by(name) %>% summarise(dQALY = sum(qaly.d)/365.25)
COST = arrivals %>% group_by(name) %>% summarise(dCOST = sum(discounted_cost))
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN )
return(avgsum)
}
results <- bk
cost.qaly(results,inputs)
Q
rm(type)
cost.qaly <- function(raw,inputs)
{
arrivals <- raw %>%  mutate(name = paste0(name,"_",replication))
#arrivals <- results %>%  mutate(name = paste0(name,"_",replication))
# Make all resources a factor (this allows for null events to still get summaries)
arrivals$resource <- factor(arrivals$resource, counters)
# Adjust all event end times from the inputs$durations
mapply(function(value, name){
arrivals[arrivals$resource == name,]$end_time <<-arrivals[arrivals$resource == name,]$start_time + value
}, value=inputs$durations, name=names(inputs$durations) )
# Truncate to end of study or life
end_times <- arrivals[arrivals$resource == 'time_in_model',]
arrivals$end_time <- pmin(arrivals$end_time,
plyr::join(arrivals[,c("name","end_time")], end_times[,c("name","end_time")], by="name", match="first")[,3])
# Compute total activity times
arrivals$activity_time <- arrivals$end_time - arrivals$start_time
# Computes discounted rate of time
arrivals$discounted_time <- discount_value(value=1,A=arrivals$start_time,B=arrivals$end_time)
# Compute Event base cost map
idx <- function(str) {as.numeric(factor(str, levels=levels(arrivals$resource)))}
base_cost_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$costs), FUN=function(name){
base_cost_map[idx(name)] <<- inputs$costs[[name]]
})
# Compute Disutility cost map
base_disutility_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$disutilities), FUN=function(name){
base_disutility_map[idx(name)] <<- inputs$disutilities[[name]]
})
names(base_disutility_map) = levels(arrivals$resource)
arrivals$cost <- base_cost_map[as.numeric(arrivals$resource)]
arrivals$discounted_cost <- ifelse(arrivals$activity_time>0,
discount_value(value=arrivals$cost,A=arrivals$start_time,B=arrivals$end_time),
discount(value = arrivals$cost,A=arrivals$start_time))
arrivals$disutility = base_disutility_map[arrivals$resource]
type <- inputs$type %>% unlist() %>% data.frame()
qaly1 <- arrivals %>% group_by(name) %>%
arrange(start_time) %>% mutate(utility = ifelse(row_number()==1,1,NA)) %>% filter(disutility>0 | utility>0) %>% #cross out events that have no impact on utility
select(name,resource,start_time,end_time,activity_time,disutility) %>%
merge(type,by="resource",all.x=TRUE) %>% #attach type of events: temp vs. permanent disutility
mutate(us=disutility,ue=disutility*(-type)) %>%  #us/ue stand for disutility at start/end time: temp event will add back disutility at end time
select(name,start_time,end_time,us,ue,resource,type) %>% melt(id.vars=c("name","resource","us","ue","type")) %>% arrange(value) %>% #separate and spread start/end time
mutate(disutility=ifelse(variable=="start_time",us,ue)) %>% arrange(name,value,desc(variable)) %>% #match disutility with start/end time
group_by(name) %>% mutate(time=lead(value)) %>% mutate(dtime=ifelse(row_number()>1,time-lag(time),time)) %>% filter(!is.na(dtime)) %>%
filter(!(type==0 & dtime==0)) #For events that permanently reduce utility, this deletes double counts of the event and prevent double counting of disutility
#For temp event, we need to keep two records (start & end) in the datasets in order to adding back disutility at end time
qaly2 <- qaly1 %>% mutate(cum1=ifelse(type==1 | is.na(type),0,disutility)) %>% #For permanent events (type==0), pass disutility to accumulate
group_by(name) %>% mutate(temp_u=1-cumsum(cum1)) %>%
mutate(cum2=ifelse(type==0 | is.na(type),0,disutility)) %>% mutate(utility=temp_u-cumsum(cum2)) %>% #For temp events, deduct accumulative disutility from temp_u
filter(utility>0) #do not count negative/zero utility in qaly computation
qaly.i <- qaly2 %>% select(name, value, time, utility) %>%
mutate(qaly.d = discount_value(utility,A=value,B=time)) #discounted QALY for each period of time
QALY = qaly.i %>% group_by(name) %>% summarise(dQALY = sum(qaly.d)/365.25)
COST = arrivals %>% group_by(name) %>% summarise(dCOST = sum(discounted_cost))
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN )
return(avgsum)
}
cost.qaly(results,inputs)
Q
type
type <- read.csv("/Users/zilu/Box Sync/today/disutility_type.csv")
class(type)
type2 <- inputs$type %>% unlist() %>% data.frame()
class(type2)
typeof(type)
typeof(type2)
type==type2
View(type)
View(type2)
View(type)
View(type2)
View(type)
View(type2)
inputs$type
data.frame(resource=name(inputs$type),type=inputs$type)
data.frame(resource=names(inputs$type),type=inputs$type)
data.frame(resource=names(inputs$type),type=unlist(inputs$type))
v <- data.frame(resource=names(inputs$type),type=unlist(inputs$type))
View(v)
v <- data.frame(resource=names(inputs$type),type=unlist(inputs$type),row.names=NULL)
v==type
any(type~=v)
any(type!=v)
discount_value = function(value,ar=annual_discount_rate,A,B)
{
r <- (1 + ar)^(1/365)-1
(value/r)*(exp(-r*A)-exp(-r*B))
}
discount = function(value,ar=annual_discount_rate,A) value / (1+ar)^(A/365.25)
cost.qaly <- function(raw,inputs)
{
arrivals <- raw %>%  mutate(name = paste0(name,"_",replication))
#arrivals <- results %>%  mutate(name = paste0(name,"_",replication))
# Make all resources a factor (this allows for null events to still get summaries)
arrivals$resource <- factor(arrivals$resource, counters)
# Adjust all event end times from the inputs$durations
mapply(function(value, name){
arrivals[arrivals$resource == name,]$end_time <<-arrivals[arrivals$resource == name,]$start_time + value
}, value=inputs$durations, name=names(inputs$durations) )
# Truncate to end of study or life
end_times <- arrivals[arrivals$resource == 'time_in_model',]
arrivals$end_time <- pmin(arrivals$end_time,
plyr::join(arrivals[,c("name","end_time")], end_times[,c("name","end_time")], by="name", match="first")[,3])
# Compute total activity times
arrivals$activity_time <- arrivals$end_time - arrivals$start_time
# Computes discounted rate of time
arrivals$discounted_time <- discount_value(value=1,A=arrivals$start_time,B=arrivals$end_time)
# Compute Event base cost map
idx <- function(str) {as.numeric(factor(str, levels=levels(arrivals$resource)))}
base_cost_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$costs), FUN=function(name){
base_cost_map[idx(name)] <<- inputs$costs[[name]]
})
# Compute Disutility cost map
base_disutility_map <- rep(0, nlevels(arrivals$resource))
sapply(names(inputs$disutilities), FUN=function(name){
base_disutility_map[idx(name)] <<- inputs$disutilities[[name]]
})
names(base_disutility_map) = levels(arrivals$resource)
arrivals$cost <- base_cost_map[as.numeric(arrivals$resource)]
arrivals$discounted_cost <- ifelse(arrivals$activity_time>0,
discount_value(value=arrivals$cost,A=arrivals$start_time,B=arrivals$end_time),
discount(value = arrivals$cost,A=arrivals$start_time))
arrivals$disutility = base_disutility_map[arrivals$resource]
type <- data.frame(resource=names(inputs$type),type=unlist(inputs$type),row.names=NULL)
qaly1 <- arrivals %>% group_by(name) %>%
arrange(start_time) %>% mutate(utility = ifelse(row_number()==1,1,NA)) %>% filter(disutility>0 | utility>0) %>% #cross out events that have no impact on utility
select(name,resource,start_time,end_time,activity_time,disutility) %>%
merge(type,by="resource",all.x=TRUE) %>% #attach type of events: temp vs. permanent disutility
mutate(us=disutility,ue=disutility*(-type)) %>%  #us/ue stand for disutility at start/end time: temp event will add back disutility at end time
select(name,start_time,end_time,us,ue,resource,type) %>% melt(id.vars=c("name","resource","us","ue","type")) %>% arrange(value) %>% #separate and spread start/end time
mutate(disutility=ifelse(variable=="start_time",us,ue)) %>% arrange(name,value,desc(variable)) %>% #match disutility with start/end time
group_by(name) %>% mutate(time=lead(value)) %>% mutate(dtime=ifelse(row_number()>1,time-lag(time),time)) %>% filter(!is.na(dtime)) %>%
filter(!(type==0 & dtime==0)) #For events that permanently reduce utility, this deletes double counts of the event and prevent double counting of disutility
#For temp event, we need to keep two records (start & end) in the datasets in order to adding back disutility at end time
qaly2 <- qaly1 %>% mutate(cum1=ifelse(type==1 | is.na(type),0,disutility)) %>% #For permanent events (type==0), pass disutility to accumulate
group_by(name) %>% mutate(temp_u=1-cumsum(cum1)) %>%
mutate(cum2=ifelse(type==0 | is.na(type),0,disutility)) %>% mutate(utility=temp_u-cumsum(cum2)) %>% #For temp events, deduct accumulative disutility from temp_u
filter(utility>0) #do not count negative/zero utility in qaly computation
qaly.i <- qaly2 %>% select(name, value, time, utility) %>%
mutate(qaly.d = discount_value(utility,A=value,B=time)) #discounted QALY for each period of time
QALY = qaly.i %>% group_by(name) %>% summarise(dQALY = sum(qaly.d)/365.25)
COST = arrivals %>% group_by(name) %>% summarise(dCOST = sum(discounted_cost))
avgsum <- data.frame(    dQALY = sum(QALY$dQALY)/inputs$vN,
dCOST = sum(COST$dCOST)/inputs$vN )
return(avgsum)
}
rm(type)
cost.qaly(results,inputs)
inputs$vN
